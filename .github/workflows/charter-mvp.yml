name: charter-mvp
on:
  workflow_dispatch:
    inputs:
      city:
        description: "Filtro texto (p.ej. barcelona). Usa 'all' para todo."
        required: false
        default: "all"
permissions:
  contents: write

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Build JSON desde sitemap → fichas → drupalSettings (sin AJAX)
        env:
          CITY: ${{ github.event.inputs.city }}
        run: |
          node - <<'JS'
          const fs = require("fs/promises");
          const ORIGIN = "https://www.consum.es";
          const CITY = (process.env.CITY || "all").toLowerCase();
          const UA = {
            "User-Agent": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 Chrome/125 Safari/537.36",
            "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
            "Accept-Language": "es-ES,es;q=0.9",
            "Referer": ORIGIN + "/"
          };

          const sleep = ms => new Promise(r=>setTimeout(r,ms));
          const norm = s => (s||"").normalize("NFD").replace(/\p{Diacritic}/gu,"").toLowerCase();

          async function get(u){
            const r = await fetch(u, { headers: UA });
            const t = await r.text();
            if (!r.ok) throw new Error(`HTTP ${r.status} ${u}\n${t.slice(0,300)}`);
            return t;
          }
          function parseSitemap(xml){
            return [...xml.matchAll(/<loc>([^<]+)<\/loc>/g)].map(m=>m[1].trim());
          }

          // 1) Saca TODAS las URLs bajo /supermercados/ (fichas y listados)
          async function collectSuperUrls(){
            const root = await get(`${ORIGIN}/sitemap.xml`);
            let locs = parseSitemap(root);
            const children = locs.filter(u=>/sitemap.*\.xml/i.test(u));
            if (children.length){
              const all=[]; for (const sm of children){ try{ all.push(...parseSitemap(await get(sm))); }catch{} }
              locs = all;
            }
            return Array.from(new Set(locs.filter(u=>u.includes("/supermercados/"))));
          }

          // 2) Extrae drupalSettings de una ficha
          function extractDrupalSettings(html){
            // preferido: <script data-drupal-selector="drupal-settings-json"> ... </script>
            const m1 = html.match(/<script[^>]+data-drupal-selector=["']drupal-settings-json["'][^>]*>([\s\S]*?)<\/script>/i);
            if (m1) { try { return JSON.parse(m1[1]); } catch {} }
            // fallback: window.drupalSettings = {...};
            const m2 = html.match(/drupalSettings\s*=\s*({[\s\S]*?})\s*;?\s*<\/script>/i);
            if (m2) { try { return JSON.parse(m2[1]); } catch {} }
            return null;
          }

          // 3) De drupalSettings → features del mapa (si hay)
          function featuresFromSettings(ds){
            const maps = ds?.geofield_google_map || ds?.settings?.geofield_google_map || {};
            return Object.values(maps).flatMap(m => m?.data?.features || []);
          }

          // 4) Detecta Charter por icono o clase
          function isCharterProp(p={}){
            const icon = String(p.icon||"").toLowerCase();
            const html = String(p.description||"").toLowerCase();
            return icon.includes("icon_map_charter") || html.includes(" charter");
          }

          // 5) Intenta atar el feature a la propia ficha por URL
          function matchFeatureToPage(features, pagePath){
            const rel = pagePath.endsWith("/") ? pagePath : pagePath + "/";
            // prioridad: el feature cuya descripción tiene un <a href="...esta ficha...">
            const byHref = features.find(f => String(f?.properties?.description||"").includes(`href="${rel}"`));
            if (byHref) return byHref;
            // si solo hay uno, usa ese
            if (features.length === 1) return features[0];
            // si hay varios, usa cualquiera que sea Charter
            const anyCharter = features.find(f => isCharterProp(f?.properties));
            return anyCharter || features[0];
          }

          (async ()=>{
            await fs.mkdir("docs", {recursive:true});
            const urls = await collectSuperUrls();

            // Filtra a fichas reales aproximando: 2º segmento tras /supermercados/ que NO parezca listado.
            // Aun así, si cuela algún listado, se descartará porque no tendrá drupalSettings con features de tienda.
            const candidates = urls.filter(u=>{
              try{
                const parts = new URL(u).pathname.replace(/^\/|\/$/g,"").split("/");
                const i = parts.indexOf("supermercados");
                const seg = parts[i+1] || "";
                if (!seg) return false;
                // heurística: listado por provincia suele ser un solo segmento "barcelona", "valencia", etc.
                // fichas llevan nombres largos con guiones.
                return seg.includes("-") || seg.length > 12;
              }catch{ return false; }
            });

            // Aplica filtro CITY por URL o lo diferimos a contenido
            const pre = CITY==="all" ? candidates : candidates.filter(u => norm(u).includes(norm(CITY)));
            console.error(`[SITEMAP] fichas=${candidates.length} prefiltradas=${pre.length}`);

            const items=[];
            let fetched=0;
            for (const u of pre){
              try{
                const html = await get(u);
                const ds = extractDrupalSettings(html);
                if (!ds) continue;
                const feats = featuresFromSettings(ds);
                if (!feats.length) continue;

                const pagePath = new URL(u).pathname;
                const feat = matchFeatureToPage(feats, pagePath);
                if (!feat) continue;

                const p = feat.properties || {};
                const d = p.data || {};
                const c = feat.geometry?.coordinates || [null,null];

                // ciudad/provincia por contenido si CITY != all
                if (CITY!=="all"){
                  const blob = `${u}\n${p.tooltip||""}\n${d.field_domicilio||""}\n${p.description||""}`;
                  if (!norm(blob).includes(norm(CITY))) continue;
                }

                // Solo Charter
                if (!isCharterProp(p)) continue;

                const href = String(p.description||"").match(/href="([^"]+)"/)?.[1] || u;
                items.push({
                  id: p.entity_id ?? null,
                  name: p.tooltip || null,
                  address: d.field_domicilio || null,
                  lat: c[1] ?? null,
                  lon: c[0] ?? null,
                  url: new URL(href, ORIGIN).toString(),
                  ensena: "Charter",
                  source: u
                });
                fetched++;
                if (fetched % 25 === 0) await sleep(150);
              }catch(e){
                // silencioso para robustez
              }
            }

            // dedupe
            const seen = new Set();
            const out = items.filter(x=>{
              const k = x.id ? `id:${x.id}` : `na:${x.name}|${x.address}`;
              if (seen.has(k)) return false; seen.add(k); return true;
            });

            await fs.writeFile("docs/charter.json", JSON.stringify({
              source: "consum.es (sitemap→ficha→drupalSettings)",
              city_filter: CITY,
              last_updated: new Date().toISOString(),
              count: out.length,
              items: out
            }, null, 2));

            await fs.writeFile("docs/charter.geojson", JSON.stringify({
              type:"FeatureCollection",
              features: out.map(s=>({
                type:"Feature",
                geometry:{ type:"Point", coordinates:[s.lon,s.lat] },
                properties:{ id:s.id,name:s.name,address:s.address,url:s.url,ensena:s.ensena }
              }))
            }, null, 2));

            console.error(`[END] total=${out.length}`);
            console.log("OK");
          })().catch(e=>{ console.error(e); process.exit(1); });
          JS

      - name: Commit if changed
        run: |
          if [[ -n "$(git status --porcelain docs)" ]]; then
            git config user.name "github-actions[bot]"
            git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
            git add docs
            git commit -m "mvp drupalSettings: ${CITY:-all} [skip ci]" || true
            git push
          else
            echo "Sin cambios"
          fi 

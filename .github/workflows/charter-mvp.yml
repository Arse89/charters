# dentro del mismo paso "Build JSON ..."
- name: Build JSON (con paginación)
  env: { CITY: ${{ github.event.inputs.city }} }
  run: |
    node - <<'JS'
    const fs = require("fs/promises");
    const CITY = (process.env.CITY || "barcelona").toLowerCase();
    const ORIGIN = "https://www.consum.es";
    const FEED  = `${ORIGIN}/get-map-list/block_supermercados_en_${CITY}/`;
    const H = {
      "User-Agent":"Mozilla/5.0",
      "Accept":"application/json, text/javascript, */*; q=0.01",
      "Accept-Language":"es-ES,es;q=0.9",
      "Referer": `${ORIGIN}/supermercados/${CITY}/`
    };

    const isCharter = (p={})=>{
      const icon = String(p.icon||"").toLowerCase();
      const html = String(p.description||"").toLowerCase();
      return icon.includes("icon_map_charter") || html.includes(" charter");
    };

    async function asJson(url, opt={}){
      const r = await fetch(url, {headers:H, ...opt});
      const t = await r.text();
      if(!r.ok) throw new Error(`HTTP ${r.status} ${url}\n${t.slice(0,300)}`);
      try { return JSON.parse(t); } catch { return null; }
    }

    function collect(settings){
      const maps = settings?.geofield_google_map || {};
      return Object.values(maps).flatMap(m => m?.data?.features ?? []);
    }

    (async ()=>{
      await fs.mkdir("docs/debug", { recursive:true });

      // 1) INIT
      const init = await asJson(FEED);
      if(!init) throw new Error("INIT no devolvió JSON");
      const set0 = init?.[0]?.settings || {};
      const ajaxViews = set0?.views?.ajaxViews || {};
      const ajaxPath  = set0?.views?.ajax_path || "/views/ajax/";
      const libs = set0?.ajaxPageState?.libraries || "";
      const theme= set0?.ajaxPageState?.theme || "";
      const ajaxURL = new URL(ajaxPath, ORIGIN).toString();

      let featsAll = collect(set0);
      console.error(`[INIT] blocks=${(set0.geofield_google_map && Object.keys(set0.geofield_google_map).length)||0} raw=${featsAll.length} charter=${featsAll.filter(f=>isCharter(f.properties)).length}`);

      // 2) AJAX con paginación
      for (const [domId, v] of Object.entries(ajaxViews)) {
        let page = 0;
        for (;; page++) {
          const form = new URLSearchParams({
            view_name: v.view_name || "supermarkets",
            view_display_id: v.view_display_id || "",
            view_args: v.view_args || "",
            view_path: v.view_path || "",
            view_base_path: v.view_base_path || "supermercados",
            view_dom_id: v.view_dom_id || "",
            pager_element: String(v.pager_element ?? 0),
            page: String(page),                 // <-- clave
            per_page: "50",                     // <-- si el view lo permite
            "ajax_page_state[libraries]": libs,
            "ajax_page_state[theme]": theme
          });

          const r = await fetch(ajaxURL, {
            method: "POST",
            headers: { ...H, "Content-Type":"application/x-www-form-urlencoded; charset=UTF-8", "X-Requested-With":"XMLHttpRequest" },
            body: form.toString()
          });

          const raw = await r.text();
          await fs.writeFile(`docs/debug/${CITY}-ajax-${domId}-p${page}.raw.txt`, raw);
          let resp; try { resp = JSON.parse(raw); } catch { resp = null; }
          if (!resp) { console.error(`[AJAX] ${v.view_display_id} p${page} sin JSON`); break; }

          const cmd = Array.isArray(resp) ? resp.find(x=>x?.command==="settings") : null;
          const setX = cmd?.settings;
          if (!setX) { console.error(`[AJAX] ${v.view_display_id} p${page} sin settings`); break; }

          const feats = collect(setX);
          const n = feats.length;
          console.error(`[AJAX] ${v.view_display_id} p${page} raw=${n} charter=${feats.filter(f=>isCharter(f.properties)).length}`);
          if (n === 0) break;                  // fin de páginas

          featsAll = featsAll.concat(feats);
          // heurística de corte: si las siguientes páginas repiten exactamente el mismo HTML, nos salimos
          if (page > 20) { console.error("[AJAX] corte preventivo >20 páginas"); break; }
        }
      }

      // 3) Normaliza + filtra + dedupe
      const items = featsAll
        .filter(f=>isCharter(f.properties))
        .map(f=>{
          const p=f.properties||{}, d=p.data||{}, c=(f.geometry?.coordinates)||[null,null];
          const href = String(p.description||"").match(/href="([^"]+)"/)?.[1] || null;
          return {
            id: p.entity_id ?? null,
            name: p.tooltip ?? null,
            address: d.field_domicilio ?? null,
            province: CITY,
            lat: c[1] ?? null,
            lon: c[0] ?? null,
            url: href ? new URL(href, ORIGIN).toString() : null,
            ensena: "Charter"
          };
        });

      const seen = new Set();
      const dedup = items.filter(x=>{
        const k = x.id ? `id:${x.id}` : `na:${x.name}|${x.address}`;
        if(seen.has(k)) return false; seen.add(k); return true;
      });

      await fs.writeFile("docs/charter.json", JSON.stringify({
        source: "consum.es (get-map-list + views/ajax paginado)",
        last_updated: new Date().toISOString(),
        count: dedup.length,
        items: dedup
      }, null, 2));

      console.error(`[END] totalRaw=${featsAll.length} totalCharter=${dedup.length}`);
      console.log("OK");
    })().catch(e=>{ console.error(e); process.exit(1); });
    JS

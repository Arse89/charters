name: charter-mvp
on:
  workflow_dispatch:
    inputs:
      city:
        description: "Filtro ciudad/provincia (p.ej. barcelona). Usa 'all' para todo."
        required: false
        default: "barcelona"
permissions:
  contents: write

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Build JSON desde sitemap (fichas reales + JSON-LD + fallback get-map)
        env:
          CITY: ${{ github.event.inputs.city }}
        run: |
          node - <<'JS'
          const fs = require("fs/promises");
          const ORIGIN = "https://www.consum.es";
          const CITY_FILTER = (process.env.CITY || "barcelona").toLowerCase();

          const H = {
            "User-Agent":"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 Chrome/125 Safari/537.36",
            "Accept":"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
            "Accept-Language":"es-ES,es;q=0.9",
            "Referer": ORIGIN + "/"
          };

          const PROVINCES = new Set([
            "valencia","alicante","castellon","barcelona","tarragona","lleida","girona",
            "murcia","albacete","almeria","cuenca","toledo","ciudad-real","ciudad_real"
          ]);

          const sleep = ms => new Promise(r=>setTimeout(r,ms));
          const norm = s => s.normalize("NFD").replace(/\p{Diacritic}/gu,"").toLowerCase();

          async function get(u){ const r=await fetch(u,{headers:H}); const t=await r.text(); if(!r.ok) throw new Error(`HTTP ${r.status} ${u}\n${t.slice(0,300)}`); return t; }
          async function getJSON(u){ const r=await fetch(u,{headers:{...H,Accept:"application/json"}}); const t=await r.text(); try{ return JSON.parse(t);}catch{ return null;} }

          function parseSitemap(xml){ return [...xml.matchAll(/<loc>([^<]+)<\/loc>/g)].map(m=>m[1].trim()); }

          async function collectStoreUrls(){
            const root = await get(`${ORIGIN}/sitemap.xml`);
            let locs = parseSitemap(root);

            // seguir a sitemaps secundarios
            const children = locs.filter(u=>/sitemap.*\.xml/i.test(u));
            if (children.length){
              const all=[]; for (const sm of children){ try{ all.push(...parseSitemap(await get(sm))); }catch{} }
              locs = all;
            }

            // solo rutas bajo /supermercados/ y que aparenten ser ficha (segmento != provincia)
            const urls = locs
              .filter(u => u.includes("/supermercados/"))
              .filter(u => {
                try{
                  const p = new URL(u).pathname.replace(/^\/|\/$/g,"").split("/");
                  const i = p.indexOf("supermercados");
                  if (i === -1) return false;
                  const seg = p[i+1] || "";          // segmento tras /supermercados/
                  if (!seg) return false;
                  return !PROVINCES.has(seg);        // descarta listados por provincia
                }catch{ return false; }
              });

            return Array.from(new Set(urls));
          }

          function extractJSONLD(html){
            const blocks = [...html.matchAll(/<script[^>]+type=["']application\/ld\+json["'][^>]*>([\s\S]*?)<\/script>/gi)].map(m=>m[1]);
            const out=[];
            for (const b of blocks){
              try { const v=JSON.parse(b); Array.isArray(v)?out.push(...v):out.push(v); }
              catch {
                // intenta trocear si viniera pegado
                const parts=b.split(/\n(?=\s*{\s*"@context")/);
                for(const p of parts){ try{ out.push(JSON.parse(p)); }catch{} }
              }
            }
            return out;
          }
          const pick = (objs, key) => { for (const o of objs){ if (o && o[key]!=null) return o[key]; } return null; };

          function geoFromLD(objs){
            for (const o of objs){
              const g = o?.geo || o?.GeoCoordinates || o?.location?.geo;
              if (g && g.latitude!=null && g.longitude!=null) return {lat:+g.latitude, lon:+g.longitude};
            }
            return null;
          }
          function localityFromLD(objs){
            for (const o of objs){
              const a=o?.address;
              if (a && (a.addressLocality || a.addressRegion || a.addressCountry)){
                return [a.addressLocality,a.addressRegion].filter(Boolean).join(", ");
              }
            }
            return null;
          }
          function addressLineFromLD(objs){
            for (const o of objs){
              const a=o?.address;
              if (a){
                const s=[a.streetAddress,a.postalCode,a.addressLocality,a.addressRegion].filter(Boolean).join(", ");
                if (s) return s;
              }
            }
            return null;
          }

          // detectar Charter en ficha: texto y/o icono en HTML
          function isCharterInHTML(html){
            const h = html.toLowerCase();
            return h.includes("icon_map_charter") || h.includes(" charter");
          }

          // extraer node id por varios patrones
          function extractNodeId(html){
            const patterns = [
              /<link[^>]+rel=["']shortlink["'][^>]+href=["'][^"']*\/node\/(\d+)["']/i,
              /geofield-map-node-centro-(\d+)-field-coordenadas/i,
              /data-history-node-id=["'](\d+)["']/i,
              /data-nid=["'](\d+)["']/i,
              /"entity_id"\s*:\s*"(\d+)"/i,
              /\/node\/(\d+)[^0-9]/i
            ];
            for (const re of patterns){ const m=html.match(re); if (m) return m[1]; }
            return null;
          }

          function charterFromMapJSON(json){
            const maps = json?.[0]?.settings?.geofield_google_map || {};
            const feats = Object.values(maps).flatMap(b=>b?.data?.features||[]);
            const f = feats.find(x=>{
              const icon=String(x?.properties?.icon||"").toLowerCase();
              const desc=String(x?.properties?.description||"").toLowerCase();
              return icon.includes("icon_map_charter") || desc.includes(" charter");
            });
            if (!f) return null;
            const p=f.properties||{}, d=p.data||{}, c=f.geometry?.coordinates||[null,null];
            const href=String(p.description||"").match(/href="([^"]+)"/)?.[1]||null;
            return {
              id: p.entity_id ?? null,
              name: p.tooltip ?? null,
              address: d.field_domicilio ?? null,
              lat: c[1] ?? null,
              lon: c[0] ?? null,
              url: href ? new URL(href, ORIGIN).toString() : null
            };
          }

          (async ()=>{
            await fs.mkdir("docs", {recursive:true});
            await fs.mkdir("docs/debug", {recursive:true});

            const urls = await collectStoreUrls();
            console.error(`[SITEMAP] fichas candidatas=${urls.length}`);

            let kept=0, withLD=0, withGeo=0, viaMap=0, charter=0;
            const items=[];

            for (let i=0;i<urls.length;i++){
              const u = urls[i];
              try{
                const html = await get(u);

                // JSON-LD
                const ld = extractJSONLD(html);
                const types = ld.map(o=>o?.["@type"]).filter(Boolean).flat();
                const isStore = types.some(t=>String(t).toLowerCase().includes("store") || String(t).toLowerCase().includes("localbusiness"));
                if (!isStore) continue; // descarta listados residuales

                kept++;

                const name = pick(ld,"name");
                const addrLine = addressLineFromLD(ld);
                const geo = geoFromLD(ld);
                if (ld.length) withLD++;

                // filtro por ciudad/provincia usando LD o contenido
                const loc = localityFromLD(ld) || "";
                const hayCiudad = CITY_FILTER==="all" ? true :
                                  norm(u).includes(norm(CITY_FILTER)) ||
                                  norm(loc).includes(norm(CITY_FILTER)) ||
                                  norm(html).includes(norm(CITY_FILTER));
                if (!hayCiudad) continue;

                // Detecta Charter
                let isCharter = isCharterInHTML(html);

                // Si no es concluyente, intenta get-map/<id>
                let lat = geo?.lat ?? null, lon = geo?.lon ?? null;
                let id = null;

                if (!isCharter || lat==null || lon==null){
                  const nid = extractNodeId(html);
                  if (nid){
                    id = nid;
                    const mapJson = await getJSON(`${ORIGIN}/get-map/${nid}/`);
                    const fromMap = charterFromMapJSON(mapJson);
                    if (fromMap){
                      isCharter = true;
                      lat = fromMap.lat ?? lat;
                      lon = fromMap.lon ?? lon;
                      // completa nombre/dirección si faltan
                      const n2 = fromMap.name || name || null;
                      const a2 = fromMap.address || addrLine || null;
                      items.push({ id: fromMap.id || id, name: n2, address: a2, lat, lon, url: fromMap.url || u, ensena:"Charter" });
                      viaMap++; charter++; continue;
                    }
                  }
                }

                if (isCharter){
                  if (lat!=null && lon!=null) { withGeo++; }
                  items.push({ id, name: name||null, address: addrLine||null, lat, lon, url: u, ensena:"Charter" });
                  charter++;
                }

                if (i<5) await fs.writeFile(`docs/debug/sample${i}.html`, html);
                await sleep(120); // cortesía
              }catch(e){
                console.error(`[ERR] ${u} :: ${e.message}`);
              }
            }

            // dedupe
            const seen=new Set();
            const out=items.filter(x=>{
              const k = x.id ? `id:${x.id}` : `na:${(x.name||"")}|${(x.address||"")}`;
              if (seen.has(k)) return false; seen.add(k); return true;
            });

            await fs.writeFile("docs/charter.json", JSON.stringify({
              source:"consum.es (sitemap→ficha→JSON-LD + get-map fallback)",
              city_filter: CITY_FILTER,
              totals:{ candidates:urls.length, kept, withLD, withGeo, viaMap, charter, out: out.length },
              last_updated:new Date().toISOString(),
              count: out.length,
              items: out
            }, null, 2));

            await fs.writeFile("docs/charter.geojson", JSON.stringify({
              type:"FeatureCollection",
              features: out.map(s=>({
                type:"Feature",
                geometry:{ type:"Point", coordinates:[s.lon,s.lat] },
                properties:{ id:s.id, name:s.name, address:s.address, url:s.url, ensena:s.ensena }
              }))
            }, null, 2));

            console.error(`[END] out=${out.length} kept=${kept} withLD=${withLD} viaMap=${viaMap} charter=${charter}`);
            console.log("OK");
          })().catch(e=>{ console.error(e); process.exit(1); });
          JS

      - name: Commit if changed
        run: |
          if [[ -n "$(git status --porcelain docs)" ]]; then
            git config user.name "github-actions[bot]"
            git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
            git add docs
            git commit -m "mvp sitemap fichas: ${CITY:-barcelona} [skip ci]" || true
            git push
          else
            echo "Sin cambios"
          fi
